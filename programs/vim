-- vim revision 1

os.loadAPI("/disk/apis/libtedit")

local args = {...}

local text = ""
local path = nil
if #args > 0 then
	path = shell.resolve(args[1])
	if fs.exists(path) and not fs.isDir(path) then
		local f = io.open(path, "r")
		text = f:read("*a")
		f:close()
	end
end

local buf = libtedit.buffer.new(text)
local op = nil
local reg = ""
local entry = ""
local searchpat = nil

local function simple_motion(char, key)
	if char == "h" or key == keys.left then
		buf:setcursor(buf.cx - 1, buf.cy)
		return true
	end
	if char == "j" or key == keys.down then
		buf:setcursor(buf.cx, buf.cy + 1)
		return true
	end
	if char == "k" or key == keys.up then
		buf:setcursor(buf.cx, buf.cy - 1)
		return true
	end
	if char == "l" or key == keys.right then
		buf:setcursor(buf.cx + 1, buf.cy)
		return true
	end
	if char == "^" or key == keys.home then
		buf:setcursor(1, buf.cy)
		return true
	end
	if char == "$" or key == keys['end'] then
		buf:setcursor(100000, buf.cy)  -- FIXME
		return true
	end
	if char == "w" then
		local txt = buf.lines[buf.cy]
		local idx = txt:find("%w", buf.cx + 1)
		if idx ~= nil then
			buf:setcursor(idx, buf.cy)
		end
		return true
	end
	if char == "W" then
		local txt = buf.lines[buf.cy]
		local idx = txt:find("%S", buf.cx + 1)
		if idx ~= nil then
			buf:setcursor(idx, buf.cy)
		end
		return true
	end
	if key == keys.pageDown then
		buf:setcursor(buf.cx, buf.cy + 20)
		return true
	end
	if key == keys.pageUp then
		buf:setcursor(buf.cx, buf.cy - 20)
		return true
	end
	return false
end

local modes = {
	normal = function(char, key) 
		if simple_motion(char, key) then
			return "normal"
		end
		if char == "i" then
			return "insert"
		end
		if char == "o" then
			table.insert(buf.lines, buf.cy + 1, "")
			buf:setcursor(1, buf.cy + 1)
			return "insert"
		end
		if char == "O" then
			table.insert(buf.lines, buf.cy, "")
			buf:setcursor(1, buf.cy)
			return "insert"
		end
		if char == "a" then
			buf:setcursor(buf.cx + 1, buf.cy)
			return "insert"
		end
		if char == ":" then
			entry = ":"
			return "command"
		end
		if char == "d" then
			return "delete"
		end
		if char == "/" then
			entry = "/"
			return "search"
		end
		buf.status = "Unknown keypress"
		return "normal"
	end,

	delete = function(char, key)
		if char == "d" then
			table.remove(buf.lines, buf.cy)
			buf:setcursor(buf.cx, buf.cy)
		end
		return "normal"
	end,

	search = function(char, key)
		if key == keys.enter then
			searchpat = entry:sub(2)
			local ly = buf.cy
			local lx = buf.cx + 1
			while ly <= #buf.lines do
				local idx = buf.lines[ly]:find(pat)
				if idx ~= nil then
					buf:setcursor(idx, ly)
					return "normal"
				end
				ly = ly + 1
				lx = 1
			end
			buf.status = "Search wrapped to top"
			ly = 1
			while ly < buf.cy do
				local idx = buf.lines[ly]:find(pat)
				if idx ~= nil then
					buf:setcursor(idx, ly)
					return "normal"
				end
				ly = ly + 1
				lx = 1
			end
			buf.status = "Pattern not found"
			return "normal"
		end
		if key == keys.backspace then
			entry = entry:sub(1, -2)
			buf.status = entry
			if #entry > 0 then
				return "search"
			else
				return "normal"
			end
		end
		if char ~= nil then
			entry = entry .. char
		end
		buf.status = entry
		return "search"
	end,

	insert = function(char, key)
		if key == keys.left then
			buf:setcursor(buf.cx - 1, buf.cy)
			return "insert"
		end
		if key == keys.down then
			buf:setcursor(buf.cx, buf.cy + 1)
			return "insert"
		end
		if key == keys.up then
			buf:setcursor(buf.cx, buf.cy - 1)
			return "insert"
		end
		if key == keys.right then
			buf:setcursor(buf.cx + 1, buf.cy)
			return "insert"
		end
		if key == keys.backspace then
			buf:setcursor(buf.cx - 1, buf.cy)
			buf:delete(1)
			return "insert"
		end
		if key == keys.delete then
			buf:delete(1)
			return "insert"
		end
		if char ~= nil then
			buf:insert(char)
		end
		return "insert"
	end,

	command = function(char, key)
		if key == keys.enter then
			run_command(entry:sub(2))
			return "normal"
		end
		if key == keys.backspace then
			entry = entry:sub(1, -2)
			buf.status = entry
			if #entry > 0 then
				return "command"
			else
				return "normal"
			end
		end
		if char ~= nil then
			entry = entry .. char
		end
		buf.status = entry
		return "command"
	end,
}

local function run_command(cmd)
	local parts = {}
	for part in cmd:gmatch("%S") do
		table.insert(parts, part)
	end
	cmd = table.remove(parts, 1)
	if cmd == "write" or cmd == "w" then
		if parts[1] ~= nil then
			path = shell.resolve(parts[1])
		end
		if path == nil then
			cmd_error("Can't save: no path specified (pass an argument)")
			return false
		end
		local f = io.open(path, "w")
		for idx, line in ipairs(buf.lines) do
			f:write(line.."\n")
		end
		f:close()
		return true
	end
	if cmd == "quit" or cmd == "q" then
		running = false
		return true
	end
	if cmd == "wq" then
		if run_command("w") then
			return run_command("q")
		end
		return false
	end
	cmd_error("Unknown command: "..cmd)
	return false
end

local function cmd_error(errstr)
	buf.status = errstr
	buf:blit(term)
	os.sleep(1)
end

local mode = "normal"
local newmode
local running = true

while running do
	local ev, p1, p2, p3 = os.pullEvent()
	if ev == "key" then
		if p1 == keys.rightAlt then
			newmode = "normal"
		else
			newmode = modes[mode](nil, p1)
		end
	end
	if ev == "char" then
		newmode = modes[mode](p1, nil)
	end
	if newmode ~= nil then
		mode = newmode
	else
		buf.status = "Warning: no switch from mode"
	end
	if buf.dirty then
		buf.status = "[" .. mode .. "] " .. buf.status
		buf:blit(term.native())
	end
end
