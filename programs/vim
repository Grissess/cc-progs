REVISION = 17

os.loadAPI("/disk/apis/libtedit")

local args = {...}

local text = ""
local path = nil
if #args > 0 then
	path = shell.resolve(args[1])
	if fs.exists(path) and not fs.isDir(path) then
		local f = io.open(path, "r")
		text = f:read("*a")
		f:close()
	end
end

local buf = libtedit.buffer.new(text)
local op = nil
local reg = ""
local entry = ""
local searchpat = nil

local mode = "normal"
local newmode
local running = true

local unprintable_set = {
	keys.enter, keys.backspace,
	keys.leftCtrl, keys.leftShift, keys.leftAlt,
	keys.rightCtrl, keys.rightShift, keys.rightAlt,
	keys.kana, keys.convert, keys.noconvert,
	keys.stop, keys.kanji, keys.ax,
	keys.capsLock, keys.numLock, keys.scrollLock,
	keys.up, keys.down, keys.left, keys.right,
	keys.home, keys['end'], keys.insert, keys.delete,
	keys.pageUp, keys.pageDown,
	keys.f1, keys.f2, keys.f3, keys.f4, keys.f5,
	keys.f6, keys.f7, keys.f8, keys.f9, keys.f10,
	keys.f11, keys.f12,
}
local unprintable_map = {}
for idx, ky in ipairs(unprintable_set) do
	unprintable_map[ky] = true
end

function is_unprintable(key)
	return unprintable_map[key] == true
end

function simple_motion(char, key)
	if char == "h" or key == keys.left then
		buf:setcursor(buf.cx - 1, buf.cy)
		return true
	end
	if char == "j" or key == keys.down then
		buf:setcursor(buf.cx, buf.cy + 1)
		return true
	end
	if char == "k" or key == keys.up then
		buf:setcursor(buf.cx, buf.cy - 1)
		return true
	end
	if char == "l" or key == keys.right then
		buf:setcursor(buf.cx + 1, buf.cy)
		return true
	end
	if char == "^" or key == keys.home then
		buf:setcursor(1, buf.cy)
		return true
	end
	if char == "$" or key == keys['end'] then
		buf:setcursor(100000, buf.cy)  -- FIXME
		return true
	end
	if char == "w" then
		local txt = buf.lines[buf.cy]
		local idx = txt:find("%w", buf.cx + 1)
		if idx ~= nil then
			buf:setcursor(idx, buf.cy)
		end
		return true
	end
	if char == "W" then
		local txt = buf.lines[buf.cy]
		local idx = txt:find("%S", buf.cx + 1)
		if idx ~= nil then
			buf:setcursor(idx, buf.cy)
		end
		return true
	end
	if key == keys.pageDown then
		buf:setcursor(buf.cx, buf.cy + 20)
		return true
	end
	if key == keys.pageUp then
		buf:setcursor(buf.cx, buf.cy - 20)
		return true
	end
	return false
end

function run_command(cmd)
	local parts = {}
	for part in cmd:gmatch("%S+") do
		table.insert(parts, part)
	end
	cmd = table.remove(parts, 1)
	buf.status = ""
	if cmd == "write" or cmd == "w" then
		if parts[1] ~= nil then
			path = shell.resolve(parts[1])
		end
		if path == nil then
			cmd_error("Can't save: no path specified (pass an argument)")
			return false
		end
		local f = io.open(path, "w")
		for idx, line in ipairs(buf.lines) do
			f:write(line.."\n")
		end
		f:close()
		buf.status = buf.status .. "(saved to " .. path .. ") "
		return true
	end
	if cmd == "quit" or cmd == "q" then
		running = false
		buf.status = buf.status .. "(goodbye :)"
		return true
	end
	if cmd == "wq" then
		if run_command("w") then
			return run_command("q")
		end
		return false
	end
	cmd_error("Unknown command: "..cmd)
	return false
end

function cmd_error(errstr)
	buf.status = errstr
	buf:blit(term)
	os.sleep(1)
end

local modes = {
	normal = function(char, key) 
		buf.status = " -- NORMAL --"
		if simple_motion(char, key) then
			return "normal"
		end
		if char == "i" then
			return "insert"
		end
		if char == "I" then
			simple_motion("^", nil)
			return "insert"
		end
		if char == "o" then
			table.insert(buf.lines, buf.cy + 1, "")
			buf:setcursor(1, buf.cy + 1)
			return "insert"
		end
		if char == "O" then
			table.insert(buf.lines, buf.cy, "")
			buf:setcursor(1, buf.cy)
			return "insert"
		end
		if char == "a" then
			buf:setcursor(buf.cx + 1, buf.cy)
			return "insert"
		end
		if char == "A" then
			simple_motion("$", nil)
			return "insert"
		end
		if char == "p" then
			table.insert(buf.lines, buf.cy + 1, reg)
			return "normal"
		end
		if char == "p" then
			table.insert(buf.lines, buf.cy, reg)
			buf:setcursor(1, buf.cy + 1)
			return "normal"
		end
		if char == ":" then
			entry = ":"
			return "command"
		end
		if char == "d" then
			return "delete"
		end
		if char == "y" then
			return "yank"
		end
		if char == "/" then
			entry = "/"
			return "search"
		end
		if char ~= nil and char:match("%d") ~= nil then
			entry = char
			return "rep"
		end
		buf.status = "Unknown keypress"
		return "normal"
	end,

	delete = function(char, key)
		if char == "d" then
			table.remove(buf.lines, buf.cy)
			buf:setcursor(buf.cx, buf.cy)
			buf.status = "Line deleted"
		end
		return "normal"
	end,

	yank = function(char, key)
		if char == "y" then
			reg = buf.lines[buf.cy]
		end
		buf.status = "Yanked " .. #reg .. " chars"
		return "normal"
	end,

	search = function(char, key)
		if key == keys.enter then
			local pat = entry:sub(2)
			if #pat > 0 then
				searchpat = pat
			end
			if searchpat == nil then
				buf.status = "No prior search, aborting"
				return "normal"
			end
			local ly = buf.cy
			local lx = buf.cx + 1
			while ly <= #buf.lines do
				local idx = buf.lines[ly]:find(searchpat, lx)
				if idx ~= nil then
					buf:setcursor(idx, ly)
					return "normal"
				end
				ly = ly + 1
				lx = 1
			end
			buf.status = "Search wrapped to top"
			ly = 1
			while ly < buf.cy do
				local idx = buf.lines[ly]:find(searchpat, lx)
				if idx ~= nil then
					buf:setcursor(idx, ly)
					return "normal"
				end
				ly = ly + 1
				lx = 1
			end
			buf.status = "Pattern not found"
			return "normal"
		end
		if key == keys.backspace then
			entry = entry:sub(1, -2)
			buf.status = entry
			if #entry > 0 then
				return "search"
			else
				return "normal"
			end
		end
		if char ~= nil then
			entry = entry .. char
		end
		buf.status = entry
		return "search"
	end,

	rep = function(char, key)
		if char ~= nil and char:match("%d") then
			entry = entry .. char
			buf.status = entry
			return "rep"
		end
		local val = tonumber(entry)
		if char == "g" then
			buf:setcursor(buf.cx, val)
			return "normal"
		end
		if char == "h" or char == "j" or char == "k" or char == "l" then
			for rep = 1, val do
				simple_motion(char, nil)
			end
			return "normal"
		end
		buf.status = "Unknown motion"
		return "normal"
	end,

	insert = function(char, key)
		buf.status = " -- INSERT --"
		if key == keys.left then
			buf:setcursor(buf.cx - 1, buf.cy)
			return "insert"
		end
		if key == keys.down then
			buf:setcursor(buf.cx, buf.cy + 1)
			return "insert"
		end
		if key == keys.up then
			buf:setcursor(buf.cx, buf.cy - 1)
			return "insert"
		end
		if key == keys.right then
			buf:setcursor(buf.cx + 1, buf.cy)
			return "insert"
		end
		if key == keys.backspace then
			if buf.cx == 1 and buf.cy ~= 1 then
				buf:setcursor(10000, buf.cy - 1)
				buf.lines[buf.cy] = buf.lines[buf.cy] .. buf.lines[buf.cy + 1]
				table.remove(buf.lines, buf.cy + 1)
				return "insert"
			end
			buf:setcursor(buf.cx - 1, buf.cy)
			buf:delete(1)
			return "insert"
		end
		if key == keys.delete then
			buf:delete(1)
			return "insert"
		end
		if key == keys.enter then
			table.insert(buf.lines, buf.cy + 1, "")
			buf:setcursor(1, buf.cy + 1)
		end
		if char ~= nil then
			buf:insert(char)
		end
		return "insert"
	end,

	command = function(char, key)
		if key == keys.enter then
			run_command(entry:sub(2))
			return "normal"
		end
		if key == keys.backspace then
			entry = entry:sub(1, -2)
			buf.status = entry
			if #entry > 0 then
				return "command"
			else
				return "normal"
			end
		end
		if char ~= nil then
			entry = entry .. char
		end
		buf.status = entry
		return "command"
	end,
}

buf.status = "oc-progs vim rev " .. REVISION .. " libtedit " .. libtedit.REVISION .. " - Grissess"
buf:blit(term)

while running do
	local ev, p1, p2, p3 = os.pullEvent()
	if ev == "key" and is_unprintable(p1) then
		if p1 == keys.rightAlt then
			newmode = "normal"
		else
			newmode = modes[mode](nil, p1)
		end
	end
	if ev == "char" then
		newmode = modes[mode](p1, nil)
	end
	if ev == "mouse_click" then
		if p1 == 1 then
			buf:setcursor(buf.cx + p2 - 1, buf.cy + p3 - 1)
		end
	end
	if newmode ~= nil then
		if modes[newmode] ~= nil then
			mode = newmode
		else
			buf.status = "Warning: no such mode " .. newmode
		end
	else
		buf.status = "Warning: no switch from mode"
	end
	local oldstatus = buf.status
	buf.status = "[" .. mode .. ":" .. buf.cy .. "/" .. #buf.lines .. "," .. buf.cx .. "] " .. buf.status
	buf:blit(term)
	buf.status = oldstatus
end
