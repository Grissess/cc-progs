REVISION = 24

colorschema = {
	full = {
		default = colors.white,
		oper = colors.green,
		digit = colors.cyan,
		keyword = colors.yellow,
		func = colors.blue,
		comment = colors.pink,
		string = colors.red,
		error = colors.pink,
		highlight = colors.orange,
		status = colors.lightGray,
	},
	gray = {
		default = colors.white,
		oper = colors.white,
		digit = colors.white,
		keyword = colors.lightGray,
		func = colors.white,
		comment = colors.lightGray,
		string = colors.white,
		error = colors.gray,
		highlight = colors.lightGray,
		status = colors.lightGray,
	},
}

colormap = {
	[colors.white] = "0",
	[colors.orange] = "1",
	[colors.magenta] = "2",
	[colors.lightBlue] = "3",
	[colors.yellow] = "4",
	[colors.lime] = "5",
	[colors.pink] = "6",
	[colors.gray] = "7",
	[colors.lightGray] = "8",
	[colors.cyan] = "9",
	[colors.purple] = "a",
	[colors.blue] = "b",
	[colors.brown] = "c",
	[colors.green] = "d",
	[colors.red] = "e",
	[colors.black] = "f",
}

revcolmap = {}
for col, chr in pairs(colormap) do
	revcolmap[chr] = col
end

highlighter = {
	new = function(classes)
		return setmetatable({classes = classes}, {__index = highlighter})
	end,

	highlight = function(self, text, cs)
		local fg = string.rep(colormap[cs.default], #text)
		for class, matches in pairs(self.classes) do
			for idx, match in ipairs(matches) do
				local sidx = 1
				local mstart, mend = text:find(match, sidx)
				while mstart ~= nil do
					fg = fg:sub(0, mstart - 1) .. colormap[cs[class]]:rep(mend - mstart + 1) .. fg:sub(mend + 1)
					sidx = mend + 1
					mstart, mend = text:find(match, sidx)
				end
			end
		end
		return fg
	end,
}

syntaxes = {
	none = highlighter.new({}),
	lua = highlighter.new({
		oper = {"%{", "%}", ",", "%(", "%)", "%.", ":", "%+"},
		digit = {"%d"},
		keyword = {"function", "if", "then", "else", "while", "for", "in", "do", "end", "return", "local", "true", "false", "nil", "and", "or"},
		func = {  -- FIXME
			"setmetatable", "getmetatable", "pairs", "ipairs", "unpack", "error", "print",
			"table%.insert", "table%.remove", "table%.concat",
			"string%.rep",
		},
		comment = {"%-%-.*$"},
		string = {"\"[^\"]*\"", "'[^']*'"},
		error = {"!="},
	}),
}

function term_blit(term, text, fg)
	if term.blit ~= nil then
		term.blit(text, fg, string.rep(" ", #text))
		return
	end
	if #text <= 0 then return end
	if #text ~= #fg then error("text and fg must be of same length") end
	local idx = 1
	local curcol = nil
	while idx <= #text do
		if revcolmap[fg:sub(idx, idx)] ~= curcol then
			curcol = revcolmap[fg:sub(idx, idx)]
			term.setTextColor(curcol)
		end
		term.write(text:sub(idx, idx))
		idx = idx + 1
	end
end

buffer = {
	new = function(text)
		if text == nil then text = "" end
		local lines = {}
		local nlidx = text:find("\n")
		while nlidx ~= nil do
			table.insert(lines, text:sub(0, nlidx - 1))
			text = text:sub(nlidx + 1)
			nlidx = text:find("\n")
		end
		table.insert(lines, text)  -- guaranteed to be at least one empty line
		return setmetatable({lines = lines, cx = 1, cy = 1, sx = 1, sy = 1, width = 51, height = 19, dirty = true, syntax = syntaxes.lua, status = ""}, {__index = buffer})
	end,

	clampxy = function(self, x, y)
		if y > #self.lines then y = #self.lines end
		if y < 1 then y = 1 end
		width = #(self.lines[y])
		if x < 1 then x = 1 end
		if x > width + 1 then x = width + 1 end
		return x, y
	end,

	setscroll = function(self, x, y)
		self.sx, self.sy = self:clampxy(x, y)
		self.dirty = true
	end,

	setcursor = function(self, x, y)
		self.cx, self.cy = self:clampxy(x, y)
		if self.cy < self.sy then self.sy = self.cy end
		if self.cy > self.sy + self.height - 1 then self.sy = self.cy - self.height + 1 end
		if self.cx < self.sx then self.sx = self.cx end
		if self.cx > self.sx + self.width - 1 then self.sx = self.cx - self.width + 1 end
		self.dirty = true
	end,

	sethighlights = function(self, ...)
		self.syntax.classes.highlight = {...}
		self.dirty = true
	end,

	blit = function(self, term)
		local tw, th = term.getSize()
		local ts = th - 1
		self.width, self.height = tw, ts
		local tx, ty = 1, 1
		local bx, by = self.sx, self.sy
		term.setBackgroundColor(colors.black)
		local colset
		if term.isColor() then
			colset = colorschema.full
		else
			colset = colorschema.gray
		end

		term.clear()
		while ty <= ts and by <= #self.lines do
			local str = self.lines[by]:sub(bx, bx + tw - 1)
			if #str > 0 then
				term.setCursorPos(1, ty)
				local fg = self.syntax:highlight(str, colset)
				term_blit(term, str, fg)
			end
			ty = ty + 1
			by = by + 1
		end

		term.setCursorPos(1, th)
		term.write(string.rep(" ", tw))
		term.setCursorPos(1, th)
		term.setTextColor(colset.status or colset.default)
		term.write(self.status)

		term.setCursorPos(self.cx - self.sx + 1, self.cy - self.sy + 1)
		term.setCursorBlink(true)
		self.dirty = false
	end,

	insert = function(self, text)
		local str = self.lines[self.cy]
		str = str:sub(0, self.cx - 1) .. text .. str:sub(self.cx)
		self.lines[self.cy] = str
		self.cx = self.cx + #text
		self.dirty = true
	end,

	delete = function(self, cnt)
		if cnt == nil then cnt = 1 end
		local str = self.lines[self.cy]
		str = str:sub(0, self.cx - 1) .. str:sub(self.cx + cnt)
		self.lines[self.cy] = str
		self.dirty = true
	end,
}
